% Un document standard de type article
% 
% Rédigé pour les étudiants de sciences de la Terre de l'Université de Lyon par
% Laurent Pouilloux, Yanick Ricard, Stéphane Labrosse, Frédéric Chambat
%
% Licence Creative Commons
% Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
%
\documentclass{article}
%% PACKAGES
% Regles typographiques francaises
\usepackage[french]{babel}
% Utilisation des accents et d'un encodage standard (UTF8)
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
% Chargement d'une police
\usepackage[scaled]{helvet}
\renewcommand*\familydefault{\sfdefault}
% Dimensions de la page
\usepackage{a4wide}
% Creation des liens hypertextes dans le document
\usepackage[colorlinks=true]{hyperref}
% Definition des entetes de pages
\usepackage{fancyhdr}
\pagestyle{fancyplain}
% Utilisation d'images
\usepackage{graphicx}
% Utilisation de tableaux evolues
\usepackage{tabularx}
% Commandes pour les URL et email
\usepackage{url}
% Pour faire des exemples d'utilisation de commandes LaTeX
\usepackage{example}
% Gestion avancee de la bibliographie
\usepackage[]{natbib}
% Les couleurs
\usepackage{color}
% Les algorithmes
\usepackage[ruled]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

%% COMMANDES
% Profondeur de la table des matieres
\setcounter{tocdepth}{2}
% Agrandissement de la zone reservee aux entetes
\addtolength{\headheight}{1.5pt}
% Definitions de commandes pour mettre en couleur
%
\fancyfoot[RO, LE]{Antonin DUREY et Jihad EL FAKAWI} 
\fancyfoot[LO, RE]{Outils pour la Programmation des Logiciels} 


\begin{document}

% Informations concernant le document
\title{Analyse et tri de stacktraces pour la complétion du buckets}
\author{Antonin DUREY, Jihad EL FAKAWI}
\date{Novembre 2016}
% Page de titre automatique
\maketitle

\newpage

% Generation de la table des mati\`eres
\tableofcontents

\newpage
\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\paragraph{}
De nos jours, les crashs de logiciels ou de programmes sont quotidiens et les grosses applications doivent faire face à des milliers de rapport de crashs. L’envoi de ces rapports aux développeurs est néanmoins essentiel pour permettre à ceux-ci de corriger les problèmes et failles. Pour simplifier l’analyse de ces rapports, ils sont triés par bucket. Un bucket rassemble ainsi une série de rapports dont la source du problème est très certainement la même. Grâce à cela, lorsque les développeurs analyserons les rapports contenus dans chacun des bucket, ils disposeront d’une grande quantité d’information pour corriger le problème.


\paragraph{}
Dans le cadre du module OPL de notre Master 2 IAGL, nous avons été amenés à réaliser un projet qui porte sur l’analyse de crash. Sur ce projet, nous avons implémenté le tri de rapports d’erreurs dans des buckets.
    
    
\paragraph{}
Pour trier ces rapports, nous avons implémenté plusieurs algorithmes. Dans un premier temps, nous les avons triés de manière aléatoire. Dans un second temps, nous avons attribué un certain nombre de points aux buckets en fonction des points communs entre le rapport à trier et les rapports contenus dans le bucket. Le bucket choisi est alors celui dont le score est le plus élevé. Le troisième algorithme est une variante du second, il calcule la moyenne des points par nombre de lignes d’erreurs et par nombre de rapports dans un bucket.


\paragraph{}
L’évaluation de nos résultats a été facilité par l’infrastructure mise en place. En effet, nous pouvions soumettre nos résultat, c’est-à-dire l’attribution des rapports d’erreurs à un bucket précis. Grâce à cela, nous avons constaté que notre troisième et dernier algorithme est plus performant que le second, lui même plus performant que le premier. Néanmoins, ces 2 dernières solutions présentent l’inconvénient de prendre un temps conséquent lors du tri - plusieurs dizaines de secondes avec les données fournies.

\paragraph{}
Ce rapport présente ces travaux en 3 parties. La première est consacré au travail technique qui a été effectué. La seconde se concentre sur l'évaluation des résultats et des algorithmes. Enfin, la troisième et dernière partie traite des améliorations et des évolutions possibles du projet.

\newpage

\section{Travail technique}

\subsection{But}


\subsection{Overview}


\subsection{Algorithmes}

\paragraph{}
Nous avons implémenté 4 algorithmes différents permettant d'analyser des stacktraces et de les incorporer à des buckets déjà existants. 

\paragraph{}
Le premier est un algorithme aléatoire qui à chaque stacktrace à trier, associe un numéro de bucket alétaoire parmis ceux existants.
~~\\

\IncMargin{1em}
\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\KwData{les buckets existants nommés $buckets$ et la liste des stacktraces à trier nommée $stacktracesToBeAttributed$}
 \KwResult{une liste avec pour chaque stacktrace à trier le numéro du bucket auquel la stacktrace est associée}
\SetKwData{Stacktrace}{stacktrace}
\SetKwData{Result}{result}
\SetKwFunction{GetRandomBucketId}{getRandomBucketId}
\SetKwFunction{AddToResults}{addToResults}
 initialization\;
 \For{$stacktrace$ in $stacktracesToBeAttributed$}{
   {\AddToResults{$stacktrace$, {\GetRandomBucketId{$buckets$}}}}\;
  
 }
\caption{Algorithme d'attribution de buckets aléatoire}
\end{algorithm}

\paragraph{}
Le second algorithme parse les buckets et stacktrace existants. C'est à dire qu'il stocke les informations ligne par ligne pour chaque stacktrace. Cela permet d'obtenir la librairie ou le fichier, la méthode et la ligne ou l'erreur s'est produite.

\paragraph{}
Dans un second temps, il analyse, pour chaque stacktrace à trier, toutes ses lignes ainsi que toutes les lignes des stacktraces appartenant aux buckets, et attribue des points en fonction de la similitude entre les lignes. Ainsi, l'algorithme accumule des points de similitude par bucket. Pour chaque stacktrace, le bucket choisit est celui qui a le plus de points.
C'est cette seconde partie qui est présenté ci-dessous :
~~\\

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\KwData{les buckets existants nommés $buckets$ et la liste des stacktraces à trier nommée $stacktracesToBeAttributed$}
 \KwResult{une liste avec pour chaque stacktrace à trier le numéro du bucket auquel la stacktrace est associée}
\SetKwData{StacktracesToBeAttributed}{stacktracesToBeAttributed}
\SetKwData{Result}{result}
\SetKwData{Points}{points}
\SetKwData{BucketsWithValue}{bucketsWithValue}
\SetKwFunction{GetPointsFromLibSimilitude}{getPointsFromLibSimilitude}
\SetKwFunction{GetPointsFromFileSimilitude}{getPointsFromFileSimilitude}
\SetKwFunction{GetPointsFromMethodSimilitude}{getPointsFromMethodSimilitude}
\SetKwFunction{GetPointsFromLineSimilitude}{getPointsFromLineSimilitude}
\SetKwFunction{AddToResults}{addToResults}
\SetKwFunction{PutIntoMap}{putIntoMap}
\SetKwFunction{Initialize}{initialize}
\SetKwFunction{AddToResults}{addToResults}
\SetKwFunction{GetBucketWithHighestValue}{getBucketWithHighestValue}

 initialization\;
 \For{$stacktraceToBeAttributed$ in $stacktracesToBeAttributed$}{
	\Initialize{$bucketsWithValue$}\;
	\For{$bucket$ in $buckets$}{
		$points$ $\leftarrow$ 0\;
		\For{$stacktraceFromBucket$ in $bucket$}{
			\For{$lineFromToBeAttributed$ in $stacktraceToBeAttributed$}{
				\For{$lineFromBucket$ in $stacktraceFromBucket$}{
					$points$ $\leftarrow$ $points$ + {\GetPointsFromLibSimilitude{$lineFromBucket$, $lineFromToBeAttributed$}}\;
					$points$ $\leftarrow$ $points$ + {\GetPointsFromFileSimilitude{$lineFromBucket$, $lineFromToBeAttributed$}}\;
					$points$ $\leftarrow$ $points$ + {\GetPointsFromMethodSimilitude{$lineFromBucket$, $lineFromToBeAttributed$}}\;
					$points$ $\leftarrow$ $points$ + {\GetPointsFromLineSimilitude{$lineFromBucket$, $lineFromToBeAttributed$}}\;
				}
			}
		}
		{\PutIntoMap{$bucketsWithValue$, $bucket$, $points$}}\;
	}
	$chosenBucket$ $\leftarrow$ \GetBucketWithHighestValue{$bucketsWithValue$}\;
	\AddToResults{$map$, $chosenBucket$}\;

 }
\caption{Algorithme d'attribution de buckets basé sur le calcul de points par rapport à la similitude des lignes des stacktraces}
\end{algorithm}

\paragraph{}
Le troisième algorithme est une variante du second. Au lieu de calculer la somme des points, on calcule la moyenne des points en fonctionne du nombre de lignes de la stacktrace et du nombre de stacktraces dans un bucket. Cela donne donc un nombre de points moyen par ligne et par bucket. La fin de l'agorithme est la même : le bucket avec le plus de points est désigné.

\paragraph{}
Le quatrième et dernier algorithme et très différent. Il suppose davantage de stockage d'éléments. En effet, lors de la création des stacktraces, l'algorithme va stocker les librairies, fichiers et méthodes dans une structure sous forme de maps imbriquées. Ainsi, lors de l'attribution d'une liste, il n'y a plus besoin de parcourir chacune des lignes, mais seulement de regarder cette structure pour voir quels sont les éléments en commun.

\begin{algorithm}[H]
\SetAlgoLined
\DontPrintSemicolon
\KwData{les buckets existants nommés $buckets$ et la liste des stacktraces à trier nommée $stacktracesToBeAttributed$}
 \KwResult{une liste avec pour chaque stacktrace à trier le numéro du bucket auquel la stacktrace est associée}
\SetKwData{StacktracesToBeAttributed}{stacktracesToBeAttributed}
\SetKwData{Result}{result}
\SetKwData{Points}{points}
\SetKwData{BucketsWithValue}{bucketsWithValue}
\SetKwFunction{GetLibsUsed}{getLibsUsed}
\SetKwFunction{GetFilesUsed}{getFilesUsed}
\SetKwFunction{GetFunctionsUsed}{getFunctionsUsed}
\SetKwFunction{StacktraceUsedLib}{stacktraceUsedLib}
\SetKwFunction{StacktraceUsedFileFromLib}{stacktraceUsedFileFromLib}
\SetKwFunction{StacktraceUsedFunctionFromLibAndFile}{stacktraceUsedFunctionFromLibAndFile}
\SetKwFunction{PutIntoMap}{putIntoMap}
\SetKwFunction{AddToResults}{addToResults}
\SetKwFunction{GetBucketWithHighestValue}{getBucketWithHighestValue}
\SetKwFunction{Initialize}{initialize}

 initialization\;
 \For{$stacktraceToBeAttributed$ in $stacktracesToBeAttributed$}{
	\Initialize{$bucketsWithValue$}\;
	\For{$bucket$ in $buckets$}{
		$points$ $\leftarrow$ 0\;
		\For{$stacktraceFromBucket$ in $bucket$}{
			\tcc*{La comparaison des stacktraces s'effectue maintenant grâce à la structure contenant les librairies, fichiers et fonctions présentes dans chaque stacktrace. Le parse de ces données a été effectué précédemment lors de la création de la stacktrace}
			\For{$lib$ in \GetLibsUsed{$stacktracesToBeAttributed$}}{
				\If{\StacktraceUsedLib{$stacktraceFromBucket$, $lib$}}{
					$points$ $\leftarrow$ $points$ + 1\;
					\For{$file$ in \GetFilesUsed{$stacktracesToBeAttributed$, $lib$}}{
						\If{\StacktraceUsedFileFromLib{$stacktraceFromBucket$, $lib$, $file$}}{
							$points$ $\leftarrow$ $points$ + 5\;
							\For{$function$ in \GetFunctionsUsed{$stacktracesToBeAttributed$, $lib$, $file$}}{
								\If{\StacktraceUsedFunctionFromLibAndFile{$stacktraceFromBucket$, $lib$, $file$, $function$}}{
									$points$ $\leftarrow$ $points$ + 25\;
								}
							}
						}
					}
				}
			}
		}
		\PutIntoMap{$bucketsWithValue$, $bucket$, $points$}\;
	}
	$chosenBucket$ $\leftarrow$ \GetBucketWithHighestValue{$bucketsWithValue$}\;
	\AddToResults{$map$, $chosenBucket$}\;

 }
\caption{Algorithme d'attribution de buckets basé sur le calcul de points par rapport au nombre de librairies, fichiers et fonctions en commun}
\end{algorithm}

\subsection{Architecture}

\subsection{Implémentation}

\subsection{Utilisation}

\section{Évaluation}

\subsection{Efficacité}

\subsection{Complexité}

\subsection{Performance}
334/1248

\section{Améliorations}

\subsection{Solutions existantes}

\subsection{Idées d'algorithmes}



\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}



\end{document}